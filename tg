from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import CallbackContext, ConversationHandler
import json

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
QUESTIONNAIRE_STATES = [
    'HAIR_COLOR', 'EYE_COLOR', 'SKIN_TONE', 'FACE_SHAPE',
    'EYE_SHAPE', 'MAKEUP_FOCUS', 'MAKEUP_OCCASION', 'ADDITIONAL_PREFS'
]

class MakeupBot:
    def __init__(self):
        self.questionnaire = QuestionnaireManager()
        self.user_data = {}  # –ë—É–¥–µ—Ç —Ö—Ä–∞–Ω–∏—Ç—å –æ—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    
    async def start_questionnaire(self, update: Update, context: CallbackContext):
        """–ù–∞—á–∏–Ω–∞–µ—Ç –æ–ø—Ä–æ—Å"""
        user_id = update.effective_user.id
        self.user_data[user_id] = {
            'answers': {},
            'current_question': 'hair_color'
        }
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–≤—ã–π –≤–æ–ø—Ä–æ—Å
        first_question = self.questionnaire.get_question_by_id('hair_color')
        if first_question:
            message = self.questionnaire.format_question_for_telegram(first_question)
            
            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –æ—Ç–≤–µ—Ç–æ–≤
            keyboard = []
            for i, option in enumerate(first_question.options, 1):
                keyboard.append([InlineKeyboardButton(
                    f"{i}. {option.text}", 
                    callback_data=f"answer:{first_question.id}:{option.id}"
                )])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                message,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            
            return QUESTIONNAIRE_STATES[0]
    
    async def handle_answer(self, update: Update, context: CallbackContext):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        query = update.callback_query
        await query.answer()
        
        user_id = update.effective_user.id
        _, question_id, option_id = query.data.split(':')
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–≤–µ—Ç
        if user_id in self.user_data:
            if question_id not in self.user_data[user_id]['answers']:
                self.user_data[user_id]['answers'][question_id] = []
            self.user_data[user_id]['answers'][question_id].append(option_id)
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
        current_state = context.user_data.get('state')
        if current_state:
            current_index = QUESTIONNAIRE_STATES.index(current_state)
            if current_index + 1 < len(QUESTIONNAIRE_STATES):
                next_state = QUESTIONNAIRE_STATES[current_index + 1]
                
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º ID —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                question_map = {
                    'HAIR_COLOR': 'eye_color',
                    'EYE_COLOR': 'skin_tone',
                    'SKIN_TONE': 'face_shape',
                    'FACE_SHAPE': 'eye_shape',
                    'EYE_SHAPE': 'makeup_focus',
                    'MAKEUP_FOCUS': 'makeup_occasion',
                    'MAKEUP_OCCASION': 'additional_preferences'
                }
                
                next_question_id = question_map.get(current_state)
                if next_question_id:
                    next_question = self.questionnaire.get_question_by_id(next_question_id)
                    
                    if next_question:
                        message = self.questionnaire.format_question_for_telegram(next_question)
                        
                        # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
                        keyboard = []
                        for i, option in enumerate(next_question.options, 1):
                            keyboard.append([InlineKeyboardButton(
                                f"{i}. {option.text}",
                                callback_data=f"answer:{next_question_id}:{option.id}"
                            )])
                        
                        reply_markup = InlineKeyboardMarkup(keyboard)
                        
                        await query.edit_message_text(
                            message,
                            reply_markup=reply_markup,
                            parse_mode='Markdown'
                        )
                        
                        context.user_data['state'] = next_state
                        return next_state
        
        # –ï—Å–ª–∏ –≤–æ–ø—Ä–æ—Å—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å
        await self.complete_questionnaire(update, context)
        return ConversationHandler.END
    
    async def complete_questionnaire(self, update: Update, context: CallbackContext):
        """–ó–∞–≤–µ—Ä—à–∞–µ—Ç –æ–ø—Ä–æ—Å –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã"""
        user_id = update.effective_user.id
        
        if user_id in self.user_data:
            answers = self.user_data[user_id]['answers']
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ü–≤–µ—Ç–æ—Ç–∏–ø
            scores = self.questionnaire.calculate_color_type(answers)
            color_type = self.questionnaire.determine_dominant_color_type(scores)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            result_message = self.format_results(answers, color_type, scores)
            
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=result_message,
                parse_mode='Markdown'
            )
            
            # –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            del self.user_data[user_id]
    
    def format_results(self, answers: Dict, color_type: str, scores: Dict) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–ø—Ä–æ—Å–∞"""
        color_type_names = {
            'winter': '–ó–∏–º–∞ ‚ùÑÔ∏è',
            'spring': '–í–µ—Å–Ω–∞ üå∏',
            'summer': '–õ–µ—Ç–æ ‚òÄÔ∏è',
            'autumn': '–û—Å–µ–Ω—å üçÅ',
            'mixed': '–°–º–µ—à–∞–Ω–Ω—ã–π —Ç–∏–ø'
        }
        
        message = "*üéâ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞:*\n\n"
        message += f"*–í–∞—à —Ü–≤–µ—Ç–æ—Ç–∏–ø:* {color_type_names.get(color_type, color_type)}\n\n"
        
        message += "*–ë–∞–ª–ª—ã –ø–æ —Ü–≤–µ—Ç–æ—Ç–∏–ø–∞–º:*\n"
        for ctype, score in scores.items():
            message += f"{color_type_names[ctype]}: {score} –±–∞–ª–ª–æ–≤\n"
        
        message += "\n*–í–∞—à–∏ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è:*\n"
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ –æ—Ç–≤–µ—Ç–æ–≤
        question_info = {
            'makeup_focus': "–ê–∫—Ü–µ–Ω—Ç –Ω–∞: ",
            'makeup_occasion': "–°–ª—É—á–∞–π: ",
            'additional_preferences': "–û—Å–æ–±—ã–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è: "
        }
        
        for qid, label in question_info.items():
            if qid in answers:
                question = self.questionnaire.get_question_by_id(qid)
                if question:
                    selected_options = []
                    for opt_id in answers[qid]:
                        option = next((opt for opt in question.options if opt.id == opt_id), None)
                        if option:
                            selected_options.append(option.text)
                    
                    if selected_options:
                        message += f"{label}{', '.join(selected_options)}\n"
        
        message += "\n*üé® –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –º–∞–∫–∏—è–∂—É –±—É–¥—É—Ç –≥–æ—Ç–æ–≤—ã —á–µ—Ä–µ–∑ –º–≥–Ω–æ–≤–µ–Ω–∏–µ...*"
        
        return message
